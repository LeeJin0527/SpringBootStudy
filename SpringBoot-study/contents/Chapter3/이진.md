## Chapter3 강의 정리 

## 1. 컴퓨터 통신과 HTTP
- HTTP란? 
- HTTP 요청 / 응답의 형식
- Media types

## 2. Controller와 RestController

- Spring MVC
- Controller와 RequestMapping
- Controller와 RestController

###Model-View-Controller
구조적으로 이러한 역할로 나누어서 소스코드를 구분하기 위한 **아키텍쳐**
- View  : 사용자가 확인하는 데이터의 표현
- Controller: 사용자의 입출력을 다루는 부분
- Model: 서비스 데이터 자체
  ![](https://images.velog.io/images/jinii/post/280d9d7c-3db3-4293-b192-7bf9192ed458/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-02-15%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2011.12.32.png)

**Spring MVC 구조**
- External Client: 브라우저, 다른 클라이언트 프로그램 
- Dispatcher Servlet: 모델, 컨트롤러, 뷰 를 직접적으로 관리 
- Handler Mapping: path와 method를 연결 
- Controller: 사용자의 입출력을 다루는 부분
- Model:실제 데이터
- View Resolver: view의 역할
  ![](https://images.velog.io/images/jinii/post/5bc08114-1035-490b-a907-66a86384d454/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-02-15%20%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB%2011.17.30.png)
  
1. 외부 요청 발생
2. Dispatcher Servlet에서 HandlerMapping 으로 요청 경로 확인을 위해 전달
3. Controller로 전달
4. Model 조작
5. 갱신된 데이터 전달
6. Dispatcher Servlet으로 응답 전달
7. 응답을 Client로 전송
   1. 데이터 전송 또는
   2. 데이터를 포함한 View 제작
    
### 컨트롤러 사용법
Spring은 IOC 컨테이너를 통해서 Bean을 다루게 된다.
어노테이션을 통해 클래스가 빈으로써 IOC의 관리를 받게 됨 
```java
@Controller
public class SampleController {
    private static final Logger logger = LoggerFactory.getLogger(SampleController.class);

    @RequestMapping(
            value = "hello",
            method = RequestMethod.GET
    )
    public String hello(@RequestParam(name="id", required = false, defaultValue = "") String id){
        logger.info("PathL: hello");
        logger.info("Query Param id: "+ id);
        return "hello.html";
    }

    @GetMapping(value = "/hello/{id}")
    public String helloPath(@PathVariable("id") String id){
        logger.info("Path variable is: " +id);
        return "/hello.html";
    }


}
```

#### 일반적인 json형태로 데이터를 나타내게 하는법 : ResponseBody
```java
  @GetMapping(
            "/get-profile"
    )
    public @ResponseBody  SamplePayload getProfile(){
        return new SamplePayload("jin", 10, "Developer");
    }
```

#### 데이터를 주고받을 때 :rest_controller, ResponseBody와 같은 역할  
```java

@RestController
@RequestMapping("/rest")
public class SampleRestController {
    private static final Logger logger = LoggerFactory.getLogger(SampleRestController.class);

    @GetMapping("/sample-payload")
    public SamplePayload samplePayload(){
        return new SamplePayload("jin", 10, "Developer");
    }
}

```

#### produces : 미디어 타입 결정 
```java
 @GetMapping(
        value ="/sample-image",
        produces = MediaType.IMAGE_PNG_VALUE
)
public byte[] sampleImage() throws IOException {
        InputStream inputStream = getClass().getResourceAsStream("/static/img.jpeg");
//        inputStream = new FileInputStream(new File(""));

        return inputStream.readAllBytes();
        }
```

- >RequestMapping: 요청을 특정 메서드와 매핑하기 위해 사용하는 것
- >GetMapping: 데이터를 가져올 때 사용하는 어노테이션 
- >RequestParam: 요청 파라미터를 메소드에서 1:1로 받기 위해 사용한다.
@RequestParam을 사용하면 기본적으로 반드시 해당 파라미터가 전송되어야 한다. required : ( default : true ) 반드시 필요하지 않은 경우라면 false로 설정 !!
  
        defaultValue : required 속성이 false라면 대체해줄 값 설정
        required : ( default : true ) 반드시 필요하지 않은 경우라면 false로 설정
- > PathVariable: 매핑의 URL에 { } 로 들어가는 패스 변수(path variable)를 받는다.

- > ResponseBody: Object의 데이터를 바디에 담아서 전송하고 싶을 떄  
- > RestController : 컨트롤러 + ResponseBody