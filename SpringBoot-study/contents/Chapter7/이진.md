# 7-1 Exception Handling
- Java의 예외처리
- Spring Boot 의 예외 처리 방법들

## Exception - 예외 
특수한 처리를 필요로 하는 비상적 또는 예외적 상황
~~~java
// a 또는 b 가 null 일 경우 NullPointerException 발생 
public void compareLength(String a, String b){
    try{
        int aLength = a.length();
        int blength = b.length();
    }
    catch(NullPointerException e){
        System.out.println("null pointer exception, pass");
    }
    finally{
        //예외의 발생 여부와 관계 없이 항상 실행하는 코드 
    }
}
~~~

~~~java
// a 또는 b 가 null 일 경우 NullPointerException 발생 
// 예외 처리를 호출하는 대상에게 전가 
// 자바에서는 Method Signature 의 일부로 , 처리되지 않은 예외는 Compile Error를 발생시킨다.
// RuntimeException나 상속받은 하위 예외들은  제외 
public void compareLength(String a, String b) throws NullPointerException{
    try{
        int aLength = a.length();
        int blength = b.length();
    }
    catch(NullPointerException e){
        System.out.println("null pointer exception, pass");
    }
    finally{
        //예외의 발생 여부와 관계 없이 항상 실행하는 코드 
    }
}
~~~

## Spring Boot의 예외 처리 방법들
~~~java
1. ResponseStatusException - 단발적 예외 
2. @ExceptionHandler - controller 내부 예외 
3. HandlerExceptionResolver -예외처리 Handler
4. @ControllerAdvice - ExceptionHandler 모
~~~


## 1. ResponseStatisException 
// 비교적 최근에 많이 쓰이는 방식인듯?
~~~ java
public void deletePost(int id){
        Optional<PostEntity> target = this.postRepository.findById((long)id);
        if (target.isEmpty()){
            throw  new ResponseStatusException(HttpStatus.NOT_FOUND);
        }
         this.postRepository.delete(target.get());

    }
~~~

## 2. @ExceptionHandler
ExceptTestController
switch문에서 에러를 처리하고 핸들러익셉션으로 들어가는 형태 
~~~ java
@RestController
@RequestMapping("except")

public class ExceptTestController {

    @GetMapping("{id}")
    public void throwException(@PathVariable int id){
        switch (id){
            case 1:
                throw new PostNotExistException();
            case 2:
                throw  new PostNotInBoardException();
            default:
                throw new ResponseStatusException(HttpStatus.NOT_FOUND);
        }
    }

    @ExceptionHandler(BaseException.class) //지정된 예외에 대해서 그 예외를 처리해줌
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public ErrorResponseDto handleBaseException(BaseException exception){
        return new ErrorResponseDto(exception.getMessage()) ;
    }
}

~~~
## 3. HandlerExceptionResolver
Restcontroller 이전의 옛날 방식 

클라이언트가 처리할 수 있도록 모델 앤 뷰의 형태로 동작 
~~~java
public class PostExceptionResolver extends AbstractHandlerExceptionResolver {

    @Override
    protected ModelAndView doResolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {
        logger.debug(ex.getClass());
        if(ex instanceof BaseException){
            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
            try{
                response.getOutputStream().print(
                        new ObjectMapper().writeValueAsString(
                                new ErrorResponseDto(" in resolver message: "+ ex.getMessage())
                        )
                );
                response.setHeader("Content-Type", MediaType.APPLICATION_JSON_VALUE);
                return new ModelAndView();
            }
            catch(IOException e){
                logger.warn("Handling exception {}", e);
            }
        }
        return null;

    }
}

~~~
## 4. @ControllerAdvice
~~~java
//최근에는 이 방법을 사용
//에러를 json 형태로 처리 
//특정 컨트롤러 내에서만 되는  @ExceptionHandler의 단점을 보완 
@RestControllerAdvice
public class PostControllerAdvice {

    @ExceptionHandler(BaseException.class)
    @ResponseStatus(HttpStatus.BAD_REQUEST)
    public  ErrorResponseDto handleException(BaseException exception){
        return new ErrorResponseDto(exception.getMessage());
    }
    //validation 에서는 어떻게 에러를 처리해야할까요?
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ErrorResponseDto handleValidException(
            MethodArgumentNotValidException exception){
        return new ErrorResponseDto(exception.getMessage());
    }


}
~~~
